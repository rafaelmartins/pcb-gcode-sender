package gcode

import (
	"bufio"
	"errors"
	"io"
	"math"
	"os"
	"strings"
)

type Job []Line

func NewJob(reader io.Reader) (Job, error) {
	// this is based on gcode generated by flatcam.

	scanner := bufio.NewScanner(reader)
	scanner.Split(bufio.ScanLines)

	rv := []Line{}

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		if line == "" || strings.HasPrefix(line, "(") {
			continue
		}

		l, err := NewLine(line)
		if err != nil {
			return nil, err
		}

		rv = append(rv, l)
	}

	return rv, nil
}

func NewJobFromFile(fname string) (Job, error) {
	fp, err := os.Open(fname)
	if err != nil {
		return nil, err
	}
	defer fp.Close()

	return NewJob(fp)
}

func NewJobFromData(data string) (Job, error) {
	return NewJob(strings.NewReader(data))
}

func (j Job) String() string {
	rv := ""
	for _, l := range j {
		rv += l.String() + "\n"
	}
	return rv
}

func (j Job) GetBoundingBox() (float64, float64, float64, float64, error) {
	minX := math.Inf(1)
	minY := math.Inf(1)
	maxX := math.Inf(-1)
	maxY := math.Inf(-1)

	for _, l := range j {
		if x := l.Get('X'); x != nil {
			if x.Value < minX {
				minX = x.Value
			}
			if x.Value > maxX {
				maxX = x.Value
			}
		}
		if y := l.Get('Y'); y != nil {
			if y.Value < minY {
				minY = y.Value
			}
			if y.Value > maxY {
				maxY = y.Value
			}
		}
	}

	if math.IsInf(minX, 1) || math.IsInf(minY, 1) || math.IsInf(maxX, -1) || math.IsInf(maxY, -1) {
		return 0, 0, 0, 0, errors.New("gcode: failed to find bounding box")
	}

	return minX, minY, maxX, maxY, nil
}
